<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>In-place merge with O(n+m) swaps - Rusting along</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Topics</li><li class="chapter-item expanded "><a href="merge.html"><strong aria-hidden="true">1.</strong> Merging</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="merge_in_place.html" class="active"><strong aria-hidden="true">1.1.</strong> In-place merge with O(n+m) swaps</a></li><li class="chapter-item expanded "><a href="merge_sequencial_access.html"><strong aria-hidden="true">1.2.</strong> Sequential access across multiple slices</a></li><li class="chapter-item expanded "><a href="merge_lazy.html"><strong aria-hidden="true">1.3.</strong> Lazy merge and deferred slice mutability</a></li><li class="chapter-item expanded "><a href="merge_denormalise.html"><strong aria-hidden="true">1.4.</strong> Pattern matching: De-normalising control flow</a></li></ol></li><li class="chapter-item expanded "><a href="sort.html"><strong aria-hidden="true">2.</strong> Sorting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sort_mergesort.html"><strong aria-hidden="true">2.1.</strong> Merge sort</a></li><li class="chapter-item expanded "><a href="sort_quicksort.html"><strong aria-hidden="true">2.2.</strong> Quick sort</a></li><li class="chapter-item expanded "><a href="sort_count.html"><strong aria-hidden="true">2.3.</strong> Count sort</a></li></ol></li><li class="chapter-item expanded "><a href="selection.html"><strong aria-hidden="true">3.</strong> Selecting</a></li><li class="chapter-item expanded "><a href="graph.html"><strong aria-hidden="true">4.</strong> Graphs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph_min_cut.html"><strong aria-hidden="true">4.1.</strong> Krager's Minimum Cut</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph_contraction.html"><strong aria-hidden="true">4.1.1.</strong> Contraction Algorithm</a></li></ol></li><li class="chapter-item expanded "><a href="graph_search.html"><strong aria-hidden="true">4.2.</strong> Graph Search</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph_search_process_state.html"><strong aria-hidden="true">4.2.1.</strong> Node Processing State</a></li><li class="chapter-item expanded "><a href="graph_path_bfs_abstract.html"><strong aria-hidden="true">4.2.2.</strong> Abstracting Breadth First Search</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph_path_shortest_distance.html"><strong aria-hidden="true">4.2.2.1.</strong> Shortest Distance</a></li><li class="chapter-item expanded "><a href="graph_path_minimum_cost.html"><strong aria-hidden="true">4.2.2.2.</strong> Dijktra's Min Path Cost</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.2.3.</strong> Bellman–Ford algorithm</div></li></ol></li><li class="chapter-item expanded "><a href="graph_path_dfs_abstract.html"><strong aria-hidden="true">4.2.3.</strong> Abstracting Depth First Search</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph_path_topological_sort.html"><strong aria-hidden="true">4.2.3.1.</strong> Topological Sort</a></li><li class="chapter-item expanded "><a href="graph_connect.html"><strong aria-hidden="true">4.2.3.2.</strong> Strong Connectivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph_connect_scc.html"><strong aria-hidden="true">4.2.3.2.1.</strong> Kosaraju’s algorithm</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="graph_mst.html"><strong aria-hidden="true">4.3.</strong> Minimum Spanning Trees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="graph_mst_kruskal.html"><strong aria-hidden="true">4.3.1.</strong> Kruskal's Algorithm</a></li><li class="chapter-item expanded "><a href="graph_mst_prim.html"><strong aria-hidden="true">4.3.2.</strong> Prim's Algorithm</a></li><li class="chapter-item expanded "><a href="graph_mst_cluster.html"><strong aria-hidden="true">4.3.3.</strong> Single-linkage clustering</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rusting along</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="in-place-merge-algorithm-with-onm-swaps"><a class="header" href="#in-place-merge-algorithm-with-onm-swaps">In-place Merge Algorithm with O(n+m) swaps</a></h1>
<h2 id="general-approach"><a class="header" href="#general-approach">General Approach</a></h2>
<p>In an &quot;In place&quot; merge of two ordered arrays it is always required to maintain a pivot between merged and unmerged sub-arrays as we go over the process of</p>
<ol>
<li>Use comparison indexes <code>(c,j)</code> to find the smallest element between (a) the left and (b) right ordered arrays</li>
<li>Swap the next smallest element of the left and right sub-arrays against a pivot position <code>(p)</code></li>
<li>Repeat until we've exhausted comparing and swapping of all elements</li>
</ol>
<pre><code>Start                               Finish
==============================     ==========================
Left array       Right array       Ordered elements across arrays
+---+---+---+    +---+---+---+     +---+---+---+  +---+---+---+
| 1 | 3 | 5 | &lt;&gt; | 2 | 4 | 6 | =&gt;  | 1 | 2 | 3 |  | 4 | 5 | 6 |
+---+---+---+    +---+---+---+     +---+---+---+  +---+---+---+
  c                j

Generic Approach of using a pivot to separate 
&quot;merged&quot; from &quot;yet to be merged&quot; regions
=============================================

         | left        Right  |
         | [c]         [j]    |
+---+---+|+---+---+   +---+---+ 
| 1 | 2 ||| 3 | 5 |   | 4 | 6 | 
+---+---+|+---+---+   +---+---+ 
Merged   |     Unmerged region  
region   p: Pivot
</code></pre>
<h2 id="challenge"><a class="header" href="#challenge">Challenge</a></h2>
<h3 id="taking-a-naive-first-step"><a class="header" href="#taking-a-naive-first-step">Taking a naive first step</a></h3>
<p>By trying to swap the smallest element of the two arrays with the pivot we quickly realise that things are getting out of control very soon. For example,</p>
<pre><code>                              c  j  p   [c] &gt; [j]  Action
 c/p             j            =======   =========  ========================
[(1 , 3 , 5)]  [(2 , 4 , 6)]  1  1  1    1     2   left swap(c,p) incr(c,p)
     c/p         j                  
[ 1 ,(3 , 5)]  [(2 , 4 , 6)]  2  1  2    3     2   right swap(j,p) incr(j,p)
      c   p          j                   
[ 1 , 2 ,(5 ]  [ 3),(4 , 6)]  2  2  3    2!!   4   Fail: We lost control here! 2 isn't part of the left array
</code></pre>
<p>At this stage our partitioned region is left of <code>p</code> and equal to <code>[1,2]</code> while the unmerged region is <code>[(5!!,3),(4,6)]</code> which is clearly <strong><em>out-of-order</em></strong> and the result from then on is unpredictable. During the 2nd iteration, the left comparison index <code>[c]</code> points to a <code>2</code> rather <code>3</code> which is now at the 4th position in the right array, or the 2nd position in the unmerged partition.
Therefore, we need to find a way to maintain a solid comparison index reference <code>[c]</code> for the left array while we iterate through</p>
<h2 id="problem-solution"><a class="header" href="#problem-solution">Problem Solution</a></h2>
<h3 id="canceling-the-rotation-during-right-swaps"><a class="header" href="#canceling-the-rotation-during-right-swaps">Canceling the Rotation during right swaps</a></h3>
<p>It becomes obvious that during the right swap operation our left array is rotated left as seen below</p>
<pre><code>                              c  j  p   [c] &gt; [j]  Action
 c/p             j            =======   =========  ========================
[(1 , 3 , 5)]  [(2 , 4 , 6)]  1  1  1    1     2   left swap(c,p) incr(c,p)
     c/p         j                   
[ 1 ,(3 , 5)]  [(2 , 4 , 6)]  2  1  2    3     2   right swap(j,p) incr(j,p)
      c   p          j                  
[ 1 , 2 ,(5 ]  [ 3),(4 , 6)]  &lt;-- Here instead of [3,5] we have [5,3]
</code></pre>
<p>Moreover, the partition point <code>[p]</code> more or less points to the where the left comparison index <code>[c]</code> should have been, that is, the unmerged partition. Let's try this time with</p>
<ul>
<li>reverting the rotation effect after each right swap hence bringing the left unmerged part back to order</li>
<li>using <code>[c]</code> as both the partition and the left comparison index</li>
</ul>
<pre><code>                              c  j    [c] &gt; [j]  Action
  c              j            ====    =========  ============================
[(1 , 3 , 5)]  [(2 , 4 , 6)]  1  1     1     2   No swap, just incr(c)
      c          j                   
[ 1 ,(3 , 5)]  [(2 , 4 , 6)]  2  1     3     2   right swap(j,c), incr(c,j)
          c          j 
[ 1 , 2 ,(5 ]  [ 3),(4 , 6)]  3  2               rotate right by 1, from c to j excluded 
          c          j                   
[ 1 , 2 ,(3 ]  [ 5),(4 , 6)]  3  2     3     4   No swap, just incr(c)
                 c   j                   
[ 1 , 2 , 3 ]  [(5),(4 , 6)]  4  2     5     4   right swap(j,c), incr(c,j)
                     c   j                   
[ 1 , 2 , 3 ]  [ 4 ,(5),(6)]  5  3               rotate right by 1, from c to j excluded 
                     c   j                   
[ 1 , 2 , 3 ]  [ 4 ,(5),(6)]  5  3     5     6   No swap, just incr(c) 
                        c/j                   
[ 1 , 2 , 3 ]  [ 4 , 5 ,(6)]  6  3               c == j (!) nothing more to compare... we've finished !!
</code></pre>
<p>Nice! It works, but only on paper. Although we overcame the conflict between pivot <code>[p]</code> and left comparison index <code>[c]</code> the obvious issues here is that our indexing across the two arrays is broken. Definitely <code>6 == 3</code> isn't correct, because <code>[c]</code> has to operate in both arrays while <code>[j]</code> operates solely in the right array.</p>
<p>However, we do know that mergesort, performs merge on memory adjacent array segments hence this can be mitigated by reconstructing the parent array out of the two fragments so that, <code>working array = *left_array[0] .. *left_array[0] + (left_array.len() + right_array.len())</code></p>
<pre><code>Left Array    Right Array
+---+---+---+ +---+---+---+     
| 2 | 4 | 6 | | 1 | 3 | 5 |   Adjacent array segments
+---+---+---+ +---+---+---+     
  |   |   |    |   |   |
+---+---+---+---+---+---+     
|&amp;2 |&amp;4 |&amp;6 |&amp;1 |&amp;3 |&amp;5 |   Memory reconstructed and operated as a continuous array i.e.
+---+---+---+---+---+---+   we recast a slice with start pointer left_array[0] 
  c           j             and length = left (len + right len)*sizeof()

</code></pre>
<p>Let's repeat the example but through the memory reconstructed array.</p>
<pre><code>                           c  j    [c] &gt; [j]  Action
  c           j            ====    =========  ============================
[(1 , 3 , 5),(2 , 4 , 6)]  1  4     1     2   No swap, just incr(c)
      c       j                   
[ 1 ,(3 , 5),(2 , 4 , 6)]  2  4     3     2   right swap(j,c), incr(c,j)
          c       j 
[ 1 , 2 ,(5 , 3),(4 , 6)]  3  5               rotate right by 1, from c to j excluded
          c       j                   
[ 1 , 2 ,(3 , 5), 4 , 6)]  3  5     3     4   No swap, just incr(c)
              c   j                   
[ 1 , 2 , 3 ,(5),(4 , 6)]  4  6     5     4   right swap(j,c), incr(c,j)
                  c   j                   
[ 1 , 2 , 3 , 4 ,(5),(6)]  5  6               rotate right by 1, from c to j excluded 
                  c   j                   
[ 1 , 2 , 3 , 4 ,(5),(6)]  5  6     5     6   no swap, just incr(c) 
                     c/j                   
[ 1 , 2 , 3 , 4 , 5 , 6 ]  6  6               c == j (!) nothing more to compare... we've finished !!
</code></pre>
<p>So far so good. We have a working approach that however is dependent on adjacent-to-memory arrays for achieving the rotations</p>
<p>However, there are some things we need to be aware of</p>
<ol>
<li>Rotations won't work between non-adjacent arrays without additional code complexity to deal with the gap</li>
<li>Rotation will be computationally significant against large datasets</li>
</ol>
<p>So can we do better without need for rotations and non-adjacent to memory arrays ?</p>
<p>It appears that we can. <code>Virtual Slice</code> &amp; <code>Index Reflector</code> come to the rescue.</p>
<h2 id="virtual-slice---continuous-access-over-array-fragments"><a class="header" href="#virtual-slice---continuous-access-over-array-fragments">Virtual Slice - continuous access over array fragments</a></h2>
<p>A <code>VirtualSlice</code> is composed out of one or more array fragments, adjacent to memory or not, and enables transparently operating over the <strong>attached</strong> array fragments.</p>
<pre><code>Left Array       Right Array
+---+---+---+    +---+---+---+     
| 2 | 4 | 6 | &lt;&gt; | 1 | 3 | 5 |   Non-adjacent array segments
+---+---+---+    +---+---+---+     
  c       ^        j
          |__
       ...  | ...
+----+----+----+----+----+----+
| &amp;2 | &amp;4 | &amp;6 | &amp;1 | &amp;3 | &amp;5 |  Array of mutable references : Virtual Slice
+----+----+----+----+----+----+  i.e. &amp;2 = pointer/reference to left array[0]
 p/c             j
</code></pre>
<p>The VirtualSlice enables transparent operation over the array fragments, hence enable us to retain index consistency, we still need to tackle eliminating the costly rotations. For more detail go to the <a href="merge_sequencial_access.html">internals and sequential access section</a></p>
<h2 id="index-reflector---from-absolute-to-derived-indexing"><a class="header" href="#index-reflector---from-absolute-to-derived-indexing">Index Reflector - from absolute to derived indexing</a></h2>
<p>We know that <code>[c]</code> and <code>[p]</code> indexes are getting mixed up, as right swaps tend to move <code>[c]</code> non-sequentially causing left merge to go <strong><em>out-of-order</em></strong>.</p>
<p>What if we could somehow, had a way such that when incrementing <code>c</code> by <code>1</code>, <code>c</code> points to the next in &quot;logical order&quot; element of the left array, 100% of the times and irrelevant of where <code>[c]</code> is positioned within the VirtualSlice ?</p>
<p>This is where the <code>IndexReflector</code> comes handy. The <em>Index Reflector</em> becomes the <strong>absolute reference</strong> in terms of the <strong>ordered sequence</strong> that <code>c</code> &amp; <code>j</code> indexes have to follow and irrelevant of the non-sequential movement of <code>[c]</code> caused by every right swap.</p>
<pre><code>Left Array       Right Array
+---+---+---+    +---+---+---+     
| 2 | 4 | 6 | &lt;&gt; | 1 | 3 | 5 |   Non-adjacent array segments
+---+---+---+    +---+---+---+     
          ^       
          |_
       ...  | ...
+----+----+----+----+----+----+
| &amp;2 | &amp;4 | &amp;6 | &amp;1 | &amp;3 | &amp;5 |  Virtual Slice with derived indexes
+----+----+----+----+----+----+  c' = Index Reflector[c], j' = Index Reflector[j]
 p/c'        |   j'    |    |
         ... | ...     |    |
+----+----+----+----+----+----+
| 1  | 2  | 3  | 4  | 5  | 6  |  Index Reflector captures VirtualSlice's elements latest positions against their starting position
+----+----+----+----+----+----+  i.e. if IndexReflector[3] == 4, it would imply that VirtualSlice[4] was in the 3rd position
 p'/c            j               [p'] = x, such that Index Reflector[x] == p, where x E {c..j} 
                                 i.e. if p == 3 given IndexReflector[x] == 3, then p' == 5 if IndexReflector[5] == 3

</code></pre>
<p>In the diagram above, the Index Reflector holds the <strong>starting position</strong> of the VirtualSlice elements. Order Comparison indexes <code>[c]</code> and <code>[j]</code> are operated against the index reflector and are <strong>projected</strong> over to VirtualSlice as <code>[c']</code> and <code>[j']</code> using the transformations described in the diagram.</p>
<p>Reversely, Pivot index <code>[p]</code> is operated on the VirtualSlice and is projected over the Index Reflector as <code>[p']</code> using the transformation provided in the diagram.</p>
<p>Let's see how this is going to work; pay attention to the non-sequencial movements of <code>c'</code> and <code>p'</code>.</p>
<pre><code>Phase 1: Merge the two arrays until a comparison index goes out of bounds 

Left Arr      Rght Arr       VirtualSlice                     Index Reflector                  Compare        Action
=========     ===========    =============================    =============================    ===========    ===================
                             c'/p          j'                  c/p'         j                  [c'] &gt; [j']
[ 5, 6, 7] &lt;&gt; [ 1, 2, 3, 4]  [(5 , 6 , 7),(1 , 2 , 3 , 4)]    [(1 , 2 , 3),(4 , 5 , 6 , 7)]      5      1     swap(j', p), swap(j, p'), incr(p,j)
                                   p       c'  j'               c   p'          j                             
[ 1, 6, 7] &lt;&gt; [ 5, 2, 3, 4]  [ 1 ,(6 , 7 , 5),(2 , 3 , 4)]    [(4 , 2 , 3),(1 , 5 , 6 , 7)]      5      2     swap(j', p), swap(j, p'), incr(p,j) 
                                       p   c'      j'           c       p'          j                             
[ 1, 2, 7] &lt;&gt; [ 5, 6, 3, 4]  [ 1 , 2 ,(7 , 5 , 6),(3 , 4)]    [(4 , 5 , 3),(1 , 2 , 6 , 7)]      5      3     swap(j', p), swap(j, p'), incr(p,j)
                                          c'/p         j'      c/p'                     j                             
[ 1, 2, 3] &lt;&gt; [ 5, 6, 7, 4]  [ 1 , 2 , 3 ,(5 , 6 , 7),(4)]    [(4 , 5 , 6),(1 , 2 , 3 , 7)]      5      4     swap(j', p), swap(j, p'), incr(p,j)
                                               p       c'  j'   c   p'                       j                             
[ 1, 2, 3] &lt;&gt; [ 4, 6, 7, 5]  [ 1 , 2 , 3 , 4 ,(6 , 7 , 5)]    [(7 , 5 , 6),(1 , 2 , 3 , 4)]      x      x     &lt;-- j'/j got out of bounds ! Phase 1 completed
</code></pre>
<p>We ran-out of right array elements (<code>j</code>is over bound), which means anything below <code>[p]</code> is merged and anything including and above <code>[p]</code> just needs to be carried over. But we cannot complete as we have <strong><em>out-of-order</em></strong> elements in the unmerged partition.</p>
<p>Index Reflector to the rescue!</p>
<p>The index reflector tells us exactly what we need to do to complete the work. if you look at <code>[c .. left_array.len()]</code> / <code>[7,5,6]</code> in the index reflector, it tells us</p>
<ol>
<li>next comes the 7th element from virtual slice,</li>
<li>then the 5th element from virtual slice, and</li>
<li>finally, the 6th element from virtual slice</li>
</ol>
<p>So if we get the remainder from the VirtualSlice <code>[6,7,5]</code> and apply the above steps we'll get <code>[5,6,7]</code>. Nice !! Let's see it in action.</p>
<pre><code>Phase 2: Finishing off the remainder unmerged partition

Left Arr      Right Arr      VirtualSlice                     Index Reflector                  Compare        Action
=========     ===========    =============================    =============================    ===========    ===================
                                               p       c'  j'   c   p'                       j                             
[ 1, 2, 3] &lt;&gt; [ 4, 6, 7, 5]  [ 1 , 2 , 3 , 4 ,(6 , 7 , 5)]    [(7 , 5 , 6),(1 , 2 , 3 , 4)]      x      x     swap(c', p), swap(c, p') incr(i,c)
                                                   p   c'  j'       c   p'                   j                             
[ 1, 2, 3] &lt;&gt; [ 4, 5, 7, 6]  [ 1 , 2 , 3 , 4 , 5 ,(7 , 6)]    [(5 , 7 , 6),(1 , 2 , 3 , 4)]      x      x     swap(c', p), swap(c, p') incr(i,c)
                                                     c'/p  j'          c/p'                  j                             
[ 1, 2, 3] &lt;&gt; [ 4, 5, 6, 7]  [ 1 , 2 , 3 , 4 , 5 , 6 ,(7)]    [(5 , 6 , 7),(1 , 2 , 3 , 4)]      x      x     &lt;-- We finished ! c' and p are both on the last position
</code></pre>
<p>Phase 2 is now complete. <strong>As if by magic</strong> everything is now in position and ordered after <code>O(n+m)</code> iterations</p>
<h2 id="useful-index-reflector-properties"><a class="header" href="#useful-index-reflector-properties">Useful Index Reflector Properties</a></h2>
<ol>
<li>At completion the Index Reflector <strong>reflects</strong> the final position per element and given its starting order i.e the 4th element in VirtualSlice ends up in the 1st position, the 1st in the 5th, and so on</li>
</ol>
<pre><code>  Left Arr      Right Arr      VirtualSlice                     Index Reflector                  
  =========     ===========    =============================    =============================    
                               c'/p          j'                  c/p'         j                  
  [ 5, 6, 7] &lt;&gt; [ 1, 2, 3, 4]  [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ]    [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]      
  ...
  ...
                                                        p/c' j'          c/p'                  j                             
  [ 1, 2, 3] &lt;&gt; [ 4, 5, 6, 7]  [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ]    [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ]      
</code></pre>
<ol start="2">
<li><code>[c]</code> index is bound by <code>[0 .. left array.len]</code> range</li>
<li><code>[p']</code> index is bound by <code>[c .. left array.len]</code> range</li>
<li>Always <code>[j'] == [j]</code></li>
</ol>
<h2 id="scaling-up-performance"><a class="header" href="#scaling-up-performance">Scaling up performance</a></h2>
<p>It is important that for each iteration, we translate <code>p</code> <strong>current position</strong> onto the <code>p'</code> position with its resulting non-sequential movement. Therefore, to find <code>p'</code> and for less than 500 elements, we can map <code>p -&gt; p'</code> by searching serially within the <code>[c .. left_array.len()]</code> range; use of 3rd property. However, this approach has an <code>O(n^2)</code> time complexity as the datasets grow larger, as it renders the serial search approach into a nested loop. Eliminating such loop will retain the linearity of the algorithm.</p>
<p>Given that <code>p'</code> position is derived somehow always in relation to <code>c</code> and <code>p</code>, can we <strong>pre-calculate <code>p'</code> movement ahead of time</strong> rather calculating for current <code>p</code> ?</p>
<p>Let's use out last example and add <code>p</code> also on the index reflector and see how this plays out</p>
<pre><code>Phase 1: Merge the two arrays until a comparison index goes out of bounds 

Left Arr      Rght Arr       VirtualSlice                     Index Reflector                  Compare        Action
=========     ===========    =============================    =============================    ===========    ===================
                             c'/p          j'                c/p'/p         j                  [c'] &gt; [j']
[ 5, 6, 7] &lt;&gt; [ 1, 2, 3, 4]  [(5 , 6 , 7),(1 , 2 , 3 , 4)]    [(1 , 2 , 3),(4 , 5 , 6 , 7)]      5      1     swap(j', p), swap(j, p'), incr(p,j)
                                   p       c'  j'               c  p/p'         j                             
[ 1, 6, 7] &lt;&gt; [ 5, 2, 3, 4]  [ 1 ,(6 , 7 , 5),(2 , 3 , 4)]    [(4 , 2 , 3),(1 , 5 , 6 , 7)]      5      2     swap(j', p), swap(j, p'), incr(p,j) 
                                       p   c'      j'           c      p/p'         j                             
[ 1, 2, 7] &lt;&gt; [ 5, 6, 3, 4]  [ 1 , 2 ,(7 , 5 , 6),(3 , 4)]    [(4 , 5 , 3),(1 , 2 , 6 , 7)]      5      3     swap(j', p), swap(j, p'), incr(p,j)
                                          c'/p         j'      c/p'         p           j                             
[ 1, 2, 3] &lt;&gt; [ 5, 6, 7, 4]  [ 1 , 2 , 3 ,(5 , 6 , 7),(4)]    [(4 , 5 , 6),(1 , 2 , 3 , 7)]      5      4     swap(j', p), swap(j, p'), incr(p,j)
                                               p       c'  j'   c   p'          p           j                             
[ 1, 2, 3] &lt;&gt; [ 4, 6, 7, 5]  [ 1 , 2 , 3 , 4 ,(6 , 7 , 5)]    [(7 , 5 , 6),(1 , 2 , 3 , 4)]      x      x     &lt;-- j'/j got out of bounds ! Phase 1 completed
</code></pre>
<p>Very interesting! <code>index_reflector[p]</code> gives us the position of <code>p'</code> !</p>
<p>For example in the last iteration, when <code>p = 5</code>, <code>index_reflector[5] = 2 = p'</code> therefore <code>p' == index_reflector[2]</code>. This also explains the workings of property No 3 where <code>p'</code> is constrained within the <code>[c..left_array.len()]</code> range.</p>
<p>Let's carry on this example to the end and watch closely...</p>
<pre><code>Phase 2: Finishing off the remainder unmerged partition

Left Arr      Right Arr      VirtualSlice                     Index Reflector                  Compare        Action
=========     ===========    =============================    =============================    ===========    ===================
                                               p       c'  j'   c   p'          p           j                             
[ 1, 2, 3] &lt;&gt; [ 4, 6, 7, 5]  [ 1 , 2 , 3 , 4 ,(6 , 7 , 5)]    [(7 , 5 , 6),(1 , 2 , 3 , 2)]      x      x     swap(c', p), swap(c, p'), ** index_reflector[c]=[p] ** incr(i,c)
                                                   p   c'  j'       c   p'          p       j                             
[ 1, 2, 3] &lt;&gt; [ 4, 5, 7, 6]  [ 1 , 2 , 3 , 4 , 5 ,(7 , 6)]    [(5 , 7 , 6),(1 , 2 , 3 , 3)]      x      x     swap(c', p), swap(c, p'), ** index_reflector[c]=[p] ** incr(i,c)
                                                     c'/p  j'          c/p'             p   j                             
[ 1, 2, 3] &lt;&gt; [ 4, 5, 6, 7]  [ 1 , 2 , 3 , 4 , 5 , 6 ,(7)]    [(5 , 6 , 7),(1 , 2 , 3 , 3)]      x      x     &lt;-- We finished ! c' and p are both on the last position
</code></pre>
<p>Hold on! Where did this <code>index_reflector[c]=[p]</code> come from?</p>
<p>Et Voilà! This is the trick that predicts <code>p'</code> position at certain values of <code>p</code>. So here is what happens per above iteration:</p>
<ol>
<li>Complete left swap action &amp; store future index <code>p'</code>, that is, with <code>[c] = 7</code>,<code>p = 5</code> and <code>[p] = 2</code> we say that when <code>p == (7 = [c])</code> then <code>p'</code> should be found at position <code>2 == [p]</code></li>
<li>Complete left swap action &amp; store future index <code>p'</code>, that is, with <code>[c] = 7</code>,<code>p = 6</code> and <code>[p] = 3</code> we say that when <code>p == (7 = [c])</code> then <code>p'</code> should be found at position <code>3 == [p]</code></li>
<li>We finished!</li>
</ol>
<p>For completeness, when a right action occurs (<code>j</code> and <code>p</code> swap) similarly we need to ensure <code>index_reflector[j] = [p]</code> which is what the swap action does.</p>
<p>With this pre-calculation trick we are now able to eliminate the hidden loop which results in up to 10x increase in performance and keeps the algorithm linear.</p>
<p>Reusing the <code>index_reflector</code> for this optimisation has rendered property No 1 invalid. If we need to retain property No 1 a separate <code>index_reflector</code> for <code>p</code>/<code>p'</code> will be required.</p>
<h2 id="further-optimisations--other-uses"><a class="header" href="#further-optimisations--other-uses">Further optimisations &amp; other uses</a></h2>
<ol>
<li>Given the 4th property we can reduce the Index Reflector to <code>left_array.len()</code> reducing the memory requirements from 2(n+m) to (2n+m) in case of mergesort</li>
<li>In addition to 4th property and given the arrays are adjacent the VirtualSlice becomes a pointer to a reconstructed parent array hence the overall memory impact becomes O(n) * sizeof(usize)</li>
<li>Given the 1st property and with a separate index reflector for <code>p'</code> optimisation, we can
<ol>
<li>Develop a &quot;sort mask array&quot; through which we can access the source array segments in order and without the need of permanently mutating them
<ol>
<li><a href="./merge_lazy.html">VirtualSlice::merge_shallow</a></li>
</ol>
</li>
<li>Such &quot;sort mask&quot; can be imposed or &quot;played onto&quot; the source segments hence mutating them only when is needed
<ol>
<li><a href="./merge_lazy.html">VirtualSlice::impose_shallow_merge</a></li>
</ol>
</li>
</ol>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="merge.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="merge_sequencial_access.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="merge.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="merge_sequencial_access.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
